# VS Code AI Code Review 插件产品设计风险评估与解决方案报告

## 摘要

本报告针对面向企业（国企）前端团队的 VS Code AI Code Review 插件，在当前的基础架构（UI 侧边栏、AST 切片、并发处理）之上，梳理了在实际工程落地中可能面临的深层技术“坑”与产品体验风险，并提供了相应的解决方案概要，作为后续产品设计的依据。

## 核心问题与解决方案列表

### 1\. “本次放行”机制的脆弱性 (标记失效与 Git 污染)

**问题描述：**

目前计划使用“文件 + 行号”注入 pre-commit 钩子来标记跳过问题。代码是动态演进的，行号的微小变动会导致原有放行标记错位，不仅失效还可能引发误判。同时，自动修改文件注入标记会产生 Git“脏区”，打断开发者正常的心流体验。

**解决方案概要：**

*   **废弃行号绑定：** 放弃在 pre-commit 中使用行号作为唯一标识。
*   **代码内联注释 (首选)：** 采用类似 ESLint 的显式声明方式（如 // @ai-ignore: reason）。在用户点击“放行”时，插件利用 VS Code API 自动在目标代码行上方插入该注释。这使得放行规则与代码物理绑定，随代码移动，且对 Git 变更透明且可追溯。
*   **内容哈希 (备选)：** 对报错的代码块及其上下文计算 Hash 值进行标记，只要核心逻辑未变，即使行号偏移也能匹配。

### 2\. AST 切片导致的上下文致盲 (AI 幻觉与类型丢失)

**问题描述：**

为了优化 Token 消耗和并发速度，采用了 Babel/Vue SFC 进行 AST 切片。但这会导致被切片的函数丢失外部依赖的上下文（例如外部引入的 utils 函数定义、TS Interface 等），从而引发 AI 产生“未定义变量”等幻觉误报。

**解决方案概要：**

*   **借力 LSP (Language Server Protocol) 补全上下文：** 强烈建议利用 VS Code 原生的语言服务能力。当 AST 扫描到外部标识符时，不自己解析依赖，而是调用 VS Code 的 executeDefinitionProvider（模拟“转到定义”）获取目标文件的 URI 和对应代码片段。
*   **浅层追溯：** 仅向上追溯一层定义，避免深度递归导致 Token 爆炸。
*   **Prompt 隔离槽位：** 在发送给 AI 的 Prompt 中，明确区分【当前审查代码】与【外部引用上下文（仅供参考）】，防止 AI 对参考代码进行 Review。

### 3\. Pre-commit 拦截的性能瓶颈与团队抵触

**问题描述：**

将耗时的 AI Review 强制绑定在 pre-commit 阶段，会因为网络延迟和并发限流导致 Commit 过程极其漫长（动辄数十秒）。在国企等强调效率的环境中，这极易引起团队抵触，导致开发者集体使用 --no-verify 绕过检查。

**解决方案概要：**

*   **降级为异步“无感模式” (MVP 阶段主推)：** 将核心交互阵地转移至 VS Code 侧边栏和编辑器内（Diagnostic 波浪线）。在“保存文件”或“用户主动触发”时进行非阻塞检查。
*   **漏斗式检测机制：** 绝对不把带有明显语法/Lint 错误的代码发给 AI。利用 VS Code API 先行拦截基础错误。
*   **重度检查后置：** pre-commit 仅保留极速的本地 Lint 检查，全量/深度的 AI Review 转移至 CI/CD 流水线或 Merge Request 阶段。

### 4\. 工程规范的碎片化与规则冲突 (“标准”难以统一)

**问题描述：**

面对公司内五花八门的老旧项目，若插件强行内置并应用“公司级标准规则”，会与项目原有的 .eslintrc 严重冲突，导致老文件满屏红线（如缩进、单双引号不一致），引发强烈的开发者抗拒。

**解决方案概要：**

*   **按需启用的退让策略 (Fallback Strategy)：** 放弃强制的规则融合与注入。插件启动时探测项目根目录是否存在规范配置（如 .eslintrc, tsconfig.json 等）。
    *   **若项目有规则：** 插件完全退让，100% 直接读取并沿用项目现有规则，不注入任何内置规则。
    *   **若项目完全无规则：** 插件才启用内置的“公司底线规则”进行兜底检查。  
        这种“小秘书”姿态能实现零冲突介入，极大降低推行阻力，开发者不会因为安装插件而导致原有代码报错。
*   **Diff-Aware 增量与存量分栏展示 (核心体验)：** 无论使用哪套规则，在插件侧边栏 Tree View 中必须将问题进行物理隔离和分栏展示：
    *   **“你的增量 (Your Changes)”：** 结合 Git Diff，**默认展开**。仅展示本次代码变更（修改行/新增行）触发的问题。这是开发者当前需要修复以及后续进行 AI Review 的绝对重点。
    *   **“项目存量 (Project Issues)”：** 历史技术债，**默认折叠**。仅作提示和浏览，不阻断正常提交流程，避免开发者为历史屎山代码“背锅”。

### 5\. Linter 警告与 AI 审查的职责重叠 (重复劳作与 Token 浪费)

**问题描述：**

如果前置的规则引擎（Linter/TS）已经发现了 Warning 级别的问题并放行给 AI，AI 很可能会在 Review 报告中重复指出这些已被发现的格式或低级逻辑问题，导致报告冗余并浪费计算资源。

**解决方案概要：**

*   **AST 节点注释化 (前置拦截)：** 在 AST 切片生成最终代码发送给 AI 之前，结合 Linter 的报错行号，利用 Babel API 在对应的 AST 节点上方动态插入特定的屏蔽注释（如 // \[AI IGNORE\]: <Lint Message>）。
*   **Prompt 上下文抑制：** 在系统 Prompt 中开辟【已知问题白名单】区块，明确指示 AI 忽略这些已被静态工具捕获的问题，强制 AI 将注意力集中在深层业务逻辑、架构设计和边缘 Case 上。
*   **后置清洗：** 在前端接收到 AI 返回的建议列表后，将其与本地的 Linter Diagnostics 进行行号比对，若重合则过滤掉 AI 的重复建议。